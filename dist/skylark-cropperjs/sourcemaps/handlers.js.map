{"version":3,"sources":["handlers.js"],"names":["define","constants","utilities","[object Object]","options","container","containerData","this","minContainerWidth","Number","MIN_CONTAINER_WIDTH","minContainerHeight","MIN_CONTAINER_HEIGHT","disabled","width","height","ratio","offsetWidth","offsetHeight","canvasData","cropBoxData","restore","getCanvasData","getCropBoxData","render","setCanvasData","forEach","n","i","setCropBoxData","dragMode","DRAG_MODE_NONE","setDragMode","hasClass","dragBox","CLASS_CROP","DRAG_MODE_MOVE","DRAG_MODE_CROP","event","wheelZoomRatio","delta","preventDefault","wheeling","setTimeout","deltaY","wheelDelta","detail","zoom","buttons","button","type","pointerType","isNumber","ctrlKey","pointers","action","changedTouches","touch","identifier","getPointer","pointerId","Object","keys","length","zoomable","zoomOnTouch","ACTION_ZOOM","getData","target","DATA_ACTION","REGEXP_ACTIONS","test","dispatchEvent","element","EVENT_CROP_START","originalEvent","cropping","ACTION_CROP","addClass","CLASS_MODAL","EVENT_CROP_MOVE","assign","change","toggleClass","cropped","modal","EVENT_CROP_END"],"mappings":"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","file":"../handlers.js","sourcesContent":["define([\n    './constants',\n    './utilities'\n], function (constants, utilities) {\n    'use strict';\n    return {\n        resize() {\n            const {options, container, containerData} = this;\n            const minContainerWidth = Number(options.minContainerWidth) || constants.MIN_CONTAINER_WIDTH;\n            const minContainerHeight = Number(options.minContainerHeight) || constants.MIN_CONTAINER_HEIGHT;\n            if (this.disabled || containerData.width <= minContainerWidth || containerData.height <= minContainerHeight) {\n                return;\n            }\n            const ratio = container.offsetWidth / containerData.width;\n            if (ratio !== 1 || container.offsetHeight !== containerData.height) {\n                let canvasData;\n                let cropBoxData;\n                if (options.restore) {\n                    canvasData = this.getCanvasData();\n                    cropBoxData = this.getCropBoxData();\n                }\n                this.render();\n                if (options.restore) {\n                    this.setCanvasData(utilities.forEach(canvasData, (n, i) => {\n                        canvasData[i] = n * ratio;\n                    }));\n                    this.setCropBoxData(utilities.forEach(cropBoxData, (n, i) => {\n                        cropBoxData[i] = n * ratio;\n                    }));\n                }\n            }\n        },\n        dblclick() {\n            if (this.disabled || this.options.dragMode === constants.DRAG_MODE_NONE) {\n                return;\n            }\n            this.setDragMode(utilities.hasClass(this.dragBox, constants.CLASS_CROP) ? constants.DRAG_MODE_MOVE : constants.DRAG_MODE_CROP);\n        },\n        wheel(event) {\n            const ratio = Number(this.options.wheelZoomRatio) || 0.1;\n            let delta = 1;\n            if (this.disabled) {\n                return;\n            }\n            event.preventDefault();\n            if (this.wheeling) {\n                return;\n            }\n            this.wheeling = true;\n            setTimeout(() => {\n                this.wheeling = false;\n            }, 50);\n            if (event.deltaY) {\n                delta = event.deltaY > 0 ? 1 : -1;\n            } else if (event.wheelDelta) {\n                delta = -event.wheelDelta / 120;\n            } else if (event.detail) {\n                delta = event.detail > 0 ? 1 : -1;\n            }\n            this.zoom(-delta * ratio, event);\n        },\n        cropStart(event) {\n            const {buttons, button} = event;\n            if (this.disabled || (event.type === 'mousedown' || event.type === 'pointerdown' && event.pointerType === 'mouse') && (utilities.isNumber(buttons) && buttons !== 1 || utilities.isNumber(button) && button !== 0 || event.ctrlKey)) {\n                return;\n            }\n            const {options, pointers} = this;\n            let action;\n            if (event.changedTouches) {\n                utilities.forEach(event.changedTouches, touch => {\n                    pointers[touch.identifier] = utilities.getPointer(touch);\n                });\n            } else {\n                pointers[event.pointerId || 0] = utilities.getPointer(event);\n            }\n            if (Object.keys(pointers).length > 1 && options.zoomable && options.zoomOnTouch) {\n                action = constants.ACTION_ZOOM;\n            } else {\n                action = utilities.getData(event.target, constants.DATA_ACTION);\n            }\n            if (!constants.REGEXP_ACTIONS.test(action)) {\n                return;\n            }\n            if (utilities.dispatchEvent(this.element, constants.EVENT_CROP_START, {\n                    originalEvent: event,\n                    action\n                }) === false) {\n                return;\n            }\n            event.preventDefault();\n            this.action = action;\n            this.cropping = false;\n            if (action === constants.ACTION_CROP) {\n                this.cropping = true;\n                utilities.addClass(this.dragBox, constants.CLASS_MODAL);\n            }\n        },\n        cropMove(event) {\n            const {action} = this;\n            if (this.disabled || !action) {\n                return;\n            }\n            const {pointers} = this;\n            event.preventDefault();\n            if (utilities.dispatchEvent(this.element, constants.EVENT_CROP_MOVE, {\n                    originalEvent: event,\n                    action\n                }) === false) {\n                return;\n            }\n            if (event.changedTouches) {\n                utilities.forEach(event.changedTouches, touch => {\n                    utilities.assign(pointers[touch.identifier] || {}, utilities.getPointer(touch, true));\n                });\n            } else {\n                utilities.assign(pointers[event.pointerId || 0] || {}, utilities.getPointer(event, true));\n            }\n            this.change(event);\n        },\n        cropEnd(event) {\n            if (this.disabled) {\n                return;\n            }\n            const {action, pointers} = this;\n            if (event.changedTouches) {\n                utilities.forEach(event.changedTouches, touch => {\n                    delete pointers[touch.identifier];\n                });\n            } else {\n                delete pointers[event.pointerId || 0];\n            }\n            if (!action) {\n                return;\n            }\n            event.preventDefault();\n            if (!Object.keys(pointers).length) {\n                this.action = '';\n            }\n            if (this.cropping) {\n                this.cropping = false;\n                utilities.toggleClass(this.dragBox, constants.CLASS_MODAL, this.cropped && this.options.modal);\n            }\n            utilities.dispatchEvent(this.element, constants.EVENT_CROP_END, {\n                originalEvent: event,\n                action\n            });\n        }\n    };\n});"]}