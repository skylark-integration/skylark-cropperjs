{"version":3,"sources":["handlers.js"],"names":["define","a","b","[object Object]","options","container","containerData","this","minContainerWidth","Number","MIN_CONTAINER_WIDTH","minContainerHeight","MIN_CONTAINER_HEIGHT","disabled","width","height","ratio","offsetWidth","offsetHeight","canvasData","cropBoxData","restore","getCanvasData","getCropBoxData","render","setCanvasData","forEach","n","i","setCropBoxData","dragMode","DRAG_MODE_NONE","setDragMode","hasClass","dragBox","CLASS_CROP","DRAG_MODE_MOVE","DRAG_MODE_CROP","event","wheelZoomRatio","delta","preventDefault","wheeling","setTimeout","deltaY","wheelDelta","detail","zoom","buttons","button","type","pointerType","isNumber","ctrlKey","pointers","action","changedTouches","touch","identifier","getPointer","pointerId","Object","keys","length","zoomable","zoomOnTouch","ACTION_ZOOM","getData","target","DATA_ACTION","REGEXP_ACTIONS","test","dispatchEvent","element","EVENT_CROP_START","originalEvent","cropping","ACTION_CROP","addClass","CLASS_MODAL","EVENT_CROP_MOVE","assign","change","toggleClass","cropped","modal","EVENT_CROP_END"],"mappings":"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","file":"../handlers.js","sourcesContent":["define([\n    './constants',\n    './utilities'\n], function (a, b) {\n    'use strict';\n    return {\n        resize() {\n            const {options, container, containerData} = this;\n            const minContainerWidth = Number(options.minContainerWidth) || a.MIN_CONTAINER_WIDTH;\n            const minContainerHeight = Number(options.minContainerHeight) || a.MIN_CONTAINER_HEIGHT;\n            if (this.disabled || containerData.width <= minContainerWidth || containerData.height <= minContainerHeight) {\n                return;\n            }\n            const ratio = container.offsetWidth / containerData.width;\n            if (ratio !== 1 || container.offsetHeight !== containerData.height) {\n                let canvasData;\n                let cropBoxData;\n                if (options.restore) {\n                    canvasData = this.getCanvasData();\n                    cropBoxData = this.getCropBoxData();\n                }\n                this.render();\n                if (options.restore) {\n                    this.setCanvasData(b.forEach(canvasData, (n, i) => {\n                        canvasData[i] = n * ratio;\n                    }));\n                    this.setCropBoxData(b.forEach(cropBoxData, (n, i) => {\n                        cropBoxData[i] = n * ratio;\n                    }));\n                }\n            }\n        },\n        dblclick() {\n            if (this.disabled || this.options.dragMode === a.DRAG_MODE_NONE) {\n                return;\n            }\n            this.setDragMode(b.hasClass(this.dragBox, a.CLASS_CROP) ? a.DRAG_MODE_MOVE : a.DRAG_MODE_CROP);\n        },\n        wheel(event) {\n            const ratio = Number(this.options.wheelZoomRatio) || 0.1;\n            let delta = 1;\n            if (this.disabled) {\n                return;\n            }\n            event.preventDefault();\n            if (this.wheeling) {\n                return;\n            }\n            this.wheeling = true;\n            setTimeout(() => {\n                this.wheeling = false;\n            }, 50);\n            if (event.deltaY) {\n                delta = event.deltaY > 0 ? 1 : -1;\n            } else if (event.wheelDelta) {\n                delta = -event.wheelDelta / 120;\n            } else if (event.detail) {\n                delta = event.detail > 0 ? 1 : -1;\n            }\n            this.zoom(-delta * ratio, event);\n        },\n        cropStart(event) {\n            const {buttons, button} = event;\n            if (this.disabled || (event.type === 'mousedown' || event.type === 'pointerdown' && event.pointerType === 'mouse') && (b.isNumber(buttons) && buttons !== 1 || b.isNumber(button) && button !== 0 || event.ctrlKey)) {\n                return;\n            }\n            const {options, pointers} = this;\n            let action;\n            if (event.changedTouches) {\n                b.forEach(event.changedTouches, touch => {\n                    pointers[touch.identifier] = b.getPointer(touch);\n                });\n            } else {\n                pointers[event.pointerId || 0] = b.getPointer(event);\n            }\n            if (Object.keys(pointers).length > 1 && options.zoomable && options.zoomOnTouch) {\n                action = a.ACTION_ZOOM;\n            } else {\n                action = b.getData(event.target, a.DATA_ACTION);\n            }\n            if (!a.REGEXP_ACTIONS.test(action)) {\n                return;\n            }\n            if (b.dispatchEvent(this.element, a.EVENT_CROP_START, {\n                    originalEvent: event,\n                    action\n                }) === false) {\n                return;\n            }\n            event.preventDefault();\n            this.action = action;\n            this.cropping = false;\n            if (action === a.ACTION_CROP) {\n                this.cropping = true;\n                b.addClass(this.dragBox, a.CLASS_MODAL);\n            }\n        },\n        cropMove(event) {\n            const {action} = this;\n            if (this.disabled || !action) {\n                return;\n            }\n            const {pointers} = this;\n            event.preventDefault();\n            if (b.dispatchEvent(this.element, a.EVENT_CROP_MOVE, {\n                    originalEvent: event,\n                    action\n                }) === false) {\n                return;\n            }\n            if (event.changedTouches) {\n                b.forEach(event.changedTouches, touch => {\n                    b.assign(pointers[touch.identifier] || {}, b.getPointer(touch, true));\n                });\n            } else {\n                b.assign(pointers[event.pointerId || 0] || {}, b.getPointer(event, true));\n            }\n            this.change(event);\n        },\n        cropEnd(event) {\n            if (this.disabled) {\n                return;\n            }\n            const {action, pointers} = this;\n            if (event.changedTouches) {\n                b.forEach(event.changedTouches, touch => {\n                    delete pointers[touch.identifier];\n                });\n            } else {\n                delete pointers[event.pointerId || 0];\n            }\n            if (!action) {\n                return;\n            }\n            event.preventDefault();\n            if (!Object.keys(pointers).length) {\n                this.action = '';\n            }\n            if (this.cropping) {\n                this.cropping = false;\n                b.toggleClass(this.dragBox, a.CLASS_MODAL, this.cropped && this.options.modal);\n            }\n            b.dispatchEvent(this.element, a.EVENT_CROP_END, {\n                originalEvent: event,\n                action\n            });\n        }\n    };\n});"]}